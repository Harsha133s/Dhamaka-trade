/// Auto-generated by TradeVerseAI Agent
/// Purpose: AI integration functions for fetching user stats & insights from /ai_insights/ and Genkit

import 'dart:async';
import 'dart:math' as math;

class AiInsightsService {
  static final AiInsightsService _instance = AiInsightsService._internal();
  factory AiInsightsService() => _instance;
  AiInsightsService._internal();
  
  // Cache for insights to reduce API calls
  final Map<String, dynamic> _insightsCache = {};
  Timer? _cacheTimer;

  /// Fetch user trading insights from AI service
  Future<AiInsight> fetchTradingInsights({
    String userId = 'demo_user',
    Duration cacheDuration = const Duration(minutes: 15),
  }) async {
    final cacheKey = 'trading_insights_$userId';
    
    // Check cache first
    if (_insightsCache.containsKey(cacheKey)) {
      final cachedData = _insightsCache[cacheKey];
      if (DateTime.now().difference(cachedData['timestamp']).inMinutes < cacheDuration.inMinutes) {
        return AiInsight.fromJson(cachedData['data']);
      }
    }

    try {
      // Simulate API call to Genkit/AI service
      await Future.delayed(const Duration(seconds: 2));
      
      final insight = _generateMockInsight();
      
      // Cache the result
      _insightsCache[cacheKey] = {
        'data': insight.toJson(),
        'timestamp': DateTime.now(),
      };

      // Auto-clear cache after duration
      _cacheTimer?.cancel();
      _cacheTimer = Timer(cacheDuration, () => _insightsCache.remove(cacheKey));

      return insight;
    } catch (e) {
      throw AiInsightsException('Failed to fetch trading insights: $e');
    }
  }

  /// Fetch user analytics data
  Future<AnalyticsData> fetchAnalytics({
    String userId = 'demo_user',
    String timeframe = '30d',
  }) async {
    try {
      // Simulate API call
      await Future.delayed(const Duration(seconds: 1));
      
      return _generateMockAnalytics(timeframe);
    } catch (e) {
      throw AiInsightsException('Failed to fetch analytics: $e');
    }
  }

  /// Fetch recent trades data
  Future<List<TradeRecord>> fetchRecentTrades({
    String userId = 'demo_user',
    int limit = 10,
  }) async {
    try {
      // Simulate API call
      await Future.delayed(const Duration(seconds: 1));
      
      return _generateMockTrades(limit);
    } catch (e) {
      throw AiInsightsException('Failed to fetch recent trades: $e');
    }
  }

  /// Generate trade recommendations using AI
  Future<List<TradeRecommendation>> generateRecommendations({
    String userId = 'demo_user',
    String analysisType = 'pattern_analysis',
  }) async {
    try {
      // Simulate AI analysis
      await Future.delayed(const Duration(seconds: 3));
      
      return _generateMockRecommendations();
    } catch (e) {
      throw AiInsightsException('Failed to generate recommendations: $e');
    }
  }

  /// Update insights via Genkit cloud function
  Future<void> updateInsights({
    String userId = 'demo_user',
    Map<String, dynamic>? additionalData,
  }) async {
    try {
      // Simulate cloud function call
      await Future.delayed(const Duration(seconds: 2));
      
      // Clear cache to force refresh
      _insightsCache.clear();
      
      print('Insights updated successfully for user: $userId');
    } catch (e) {
      throw AiInsightsException('Failed to update insights: $e');
    }
  }

  // Mock data generators
  AiInsight _generateMockInsight() {
    final random = math.Random();
    final insights = [
      'Your EUR/USD trades show 72% win rate. Strong performance during Asian hours. Consider increasing position size on breakout patterns.',
      'GBP/USD momentum trading has improved by 15%. Focus on London session openings for optimal entries.',
      'Risk management excellent this week. Average R:R of 1.8:1 suggests disciplined approach. Consider scaling up gradually.',
      'Pattern recognition improving. 68% success rate on flag patterns. Review head and shoulders setups for better timing.',
    ];

    return AiInsight(
      message: insights[random.nextInt(insights.length)],
      confidence: 0.75 + (random.nextDouble() * 0.2),
      category: ['pattern_analysis', 'risk_management', 'session_timing'][random.nextInt(3)],
      recommendations: [
        'Focus on EUR/USD during Asian session',
        'Consider 1.5% position size increase',
        'Set tighter stops on trend reversals',
      ],
      generatedAt: DateTime.now(),
    );
  }

  AnalyticsData _generateMockAnalytics(String timeframe) {
    final random = math.Random();
    
    return AnalyticsData(
      winRate: 0.65 + (random.nextDouble() * 0.2),
      totalTrades: 42 + random.nextInt(20),
      avgRiskReward: 1.8 + (random.nextDouble() * 0.4),
      totalPnl: 3240.0 + (random.nextDouble() * 1000),
      avgWin: 280.0 + (random.nextDouble() * 50),
      avgLoss: 155.0 + (random.nextDouble() * 30),
      profitFactor: 1.9 + (random.nextDouble() * 0.3),
      sharpeRatio: 1.4 + (random.nextDouble() * 0.5),
      maxDrawdown: 0.08 + (random.nextDouble() * 0.05),
      timeframe: timeframe,
    );
  }

  List<TradeRecord> _generateMockTrades(int limit) {
    final symbols = ['EUR/USD', 'GBP/USD', 'USD/JPY', 'AUD/USD', 'NZD/USD'];
    final random = math.Random();
    
    return List.generate(limit, (index) {
      final isProfitable = random.nextBool();
      return TradeRecord(
        id: 'trade_${DateTime.now().millisecondsSinceEpoch + index}',
        symbol: symbols[random.nextInt(symbols.length)],
        side: random.nextBool() ? 'Long' : 'Short',
        entryPrice: 1.0800 + (random.nextDouble() * 0.1),
        exitPrice: isProfitable ? null : 1.0750 + (random.nextDouble() * 0.1),
        quantity: 10000 + (random.nextInt(50000)),
        pnl: isProfitable ? 120.0 + (random.nextDouble() * 200) : -(85.0 + (random.nextDouble() * 150)),
        openTime: DateTime.now().subtract(Duration(days: index)),
        closeTime: isProfitable ? null : DateTime.now().subtract(Duration(days: index, hours: 2)),
        status: isProfitable ? 'Open' : 'Closed',
      );
    });
  }

  List<TradeRecommendation> _generateMockRecommendations() {
    return [
      TradeRecommendation(
        symbol: 'EUR/USD',
        action: 'BUY',
        confidence: 0.78,
        reasoning: 'Strong upward momentum with RSI oversold bounce expected',
        targetPrice: 1.0950,
        stopLoss: 1.0820,
        timeframe: '4H',
      ),
      TradeRecommendation(
        symbol: 'GBP/USD',
        action: 'SELL',
        confidence: 0.65,
        reasoning: 'Resistance at 1.2800 level with bearish divergence',
        targetPrice: 1.2650,
        stopLoss: 1.2820,
        timeframe: '1H',
      ),
    ];
  }

  void dispose() {
    _cacheTimer?.cancel();
    _insightsCache.clear();
  }
}

// Data models
class AiInsight {
  final String message;
  final double confidence;
  final String category;
  final List<String> recommendations;
  final DateTime generatedAt;

  AiInsight({
    required this.message,
    required this.confidence,
    required this.category,
    required this.recommendations,
    required this.generatedAt,
  });

  factory AiInsight.fromJson(Map<String, dynamic> json) {
    return AiInsight(
      message: json['message'] ?? '',
      confidence: (json['confidence'] ?? 0.0).toDouble(),
      category: json['category'] ?? '',
      recommendations: List<String>.from(json['recommendations'] ?? []),
      generatedAt: DateTime.parse(json['generatedAt'] ?? DateTime.now().toIso8601String()),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'message': message,
      'confidence': confidence,
      'category': category,
      'recommendations': recommendations,
      'generatedAt': generatedAt.toIso8601String(),
    };
  }
}

class AnalyticsData {
  final double winRate;
  final int totalTrades;
  final double avgRiskReward;
  final double totalPnl;
  final double avgWin;
  final double avgLoss;
  final double profitFactor;
  final double sharpeRatio;
  final double maxDrawdown;
  final String timeframe;

  AnalyticsData({
    required this.winRate,
    required this.totalTrades,
    required this.avgRiskReward,
    required this.totalPnl,
    required this.avgWin,
    required this.avgLoss,
    required this.profitFactor,
    required this.sharpeRatio,
    required this.maxDrawdown,
    required this.timeframe,
  });
}

class TradeRecord {
  final String id;
  final String symbol;
  final String side;
  final double entryPrice;
  final double? exitPrice;
  final int quantity;
  final double pnl;
  final DateTime openTime;
  final DateTime? closeTime;
  final String status;

  TradeRecord({
    required this.id,
    required this.symbol,
    required this.side,
    required this.entryPrice,
    this.exitPrice,
    required this.quantity,
    required this.pnl,
    required this.openTime,
    this.closeTime,
    required this.status,
  });
}

class TradeRecommendation {
  final String symbol;
  final String action;
  final double confidence;
  final String reasoning;
  final double targetPrice;
  final double stopLoss;
  final String timeframe;

  TradeRecommendation({
    required this.symbol,
    required this.action,
    required this.confidence,
    required this.reasoning,
    required this.targetPrice,
    required this.stopLoss,
    required this.timeframe,
  });
}

class AiInsightsException implements Exception {
  final String message;
  AiInsightsException(this.message);
  
  @override
  String toString() => 'AiInsightsException: $message';
}