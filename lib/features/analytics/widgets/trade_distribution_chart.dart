/// Auto-generated by TradeVerseAI Agent
/// Purpose: Bar chart component showing trade distribution by instrument or strategy with animations

import 'package:flutter/material.dart';
import 'dart:math' as math;

class TradeDistributionChart extends StatefulWidget {
  final Map<String, int> distributionData;
  final String chartType; // 'instrument' or 'strategy'
  final bool animate;

  const TradeDistributionChart({
    Key? key,
    required this.distributionData,
    this.chartType = 'instrument',
    this.animate = true,
  }) : super(key: key);

  @override
  State<TradeDistributionChart> createState() => _TradeDistributionChartState();
}

class _TradeDistributionChartState extends State<TradeDistributionChart>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _animation;
  String? _hoveredBar;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 1200),
      vsync: this,
    );
    
    _animation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOutQuart,
    ));
    
    if (widget.animate) {
      _animationController.forward();
    } else {
      _animationController.value = 1.0;
    }
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final maxValue = widget.distributionData.values.isNotEmpty
        ? widget.distributionData.values.reduce(math.max)
        : 0;
    
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  children: [
                    Icon(
                      Icons.bar_chart,
                      color: const Color(0xFF3B82F6),
                      size: 20,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      widget.chartType == 'instrument' 
                          ? 'Trades by Instrument'
                          : 'Trades by Strategy',
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ],
                ),
                _buildViewToggle(),
              ],
            ),
            const SizedBox(height: 20),
            SizedBox(
              height: 300,
              child: AnimatedBuilder(
                animation: _animation,
                builder: (context, child) {
                  return CustomPaint(
                    painter: BarChartPainter(
                      data: widget.distributionData,
                      animationValue: _animation.value,
                      maxValue: maxValue,
                      hoveredBar: _hoveredBar,
                      chartType: widget.chartType,
                    ),
                    child: GestureDetector(
                      onPanUpdate: (details) => _handleHover(details.localPosition),
                      onTapDown: (details) => _handleTap(details.localPosition),
                      child: Container(
                        width: double.infinity,
                        height: double.infinity,
                      ),
                    ),
                  );
                },
              ),
            ),
            const SizedBox(height: 16),
            _buildLegend(),
          ],
        ),
      ),
    );
  }

  Widget _buildViewToggle() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: 0.05),
        borderRadius: BorderRadius.circular(6),
        border: Border.all(color: Colors.white.withValues(alpha: 0.1)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildToggleButton('Instrument', 'instrument'),
          _buildToggleButton('Strategy', 'strategy'),
        ],
      ),
    );
  }

  Widget _buildToggleButton(String label, String type) {
    final isSelected = widget.chartType == type;
    
    return GestureDetector(
      onTap: () {
        // In a real app, you'd call a callback to change the chart type
        // For now, we'll just show a snackbar
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Switch to $label view'),
            duration: const Duration(seconds: 1),
          ),
        );
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          color: isSelected ? const Color(0xFF3B82F6) : Colors.transparent,
          borderRadius: BorderRadius.circular(4),
        ),
        child: Text(
          label,
          style: TextStyle(
            color: isSelected ? Colors.white : Colors.white.withValues(alpha: 0.7),
            fontSize: 12,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  Widget _buildLegend() {
    final sortedEntries = widget.distributionData.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    return Wrap(
      spacing: 16,
      runSpacing: 8,
      children: sortedEntries.take(6).map((entry) {
        final color = _getColorForItem(entry.key);
        final isHovered = _hoveredBar == entry.key;
        
        return AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          padding: EdgeInsets.all(isHovered ? 8 : 6),
          decoration: BoxDecoration(
            color: isHovered ? color.withValues(alpha: 0.1) : Colors.transparent,
            borderRadius: BorderRadius.circular(6),
            border: Border.all(
              color: isHovered ? color.withValues(alpha: 0.3) : Colors.transparent,
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 12,
                height: 12,
                decoration: BoxDecoration(
                  color: color,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(width: 8),
              Text(
                '${entry.key} (${entry.value})',
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
        );
      }).toList(),
    );
  }

  Color _getColorForItem(String item) {
    const colors = [
      Color(0xFF3B82F6), // Blue
      Color(0xFF10B981), // Green
      Color(0xFFF59E0B), // Yellow
      Color(0xFFEF4444), // Red
      Color(0xFF8B5CF6), // Purple
      Color(0xFFF97316), // Orange
      Color(0xFF06B6D4), // Cyan
      Color(0xFFEC4899), // Pink
    ];
    
    final index = item.hashCode.abs() % colors.length;
    return colors[index];
  }

  void _handleHover(Offset position) {
    final barWidth = 300.0 / widget.distributionData.length;
    final barIndex = (position.dx / barWidth).floor();
    
    if (barIndex >= 0 && barIndex < widget.distributionData.length) {
      final key = widget.distributionData.keys.elementAt(barIndex);
      setState(() {
        _hoveredBar = key;
      });
    } else {
      setState(() {
        _hoveredBar = null;
      });
    }
  }

  void _handleTap(Offset position) {
    _handleHover(position);
    if (_hoveredBar != null) {
      _showBarDetails(_hoveredBar!);
    }
  }

  void _showBarDetails(String item) {
    final value = widget.distributionData[item] ?? 0;
    final total = widget.distributionData.values.reduce((a, b) => a + b);
    final percentage = (value / total * 100).toStringAsFixed(1);
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('$item Details'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Total Trades: $value'),
            Text('Percentage: $percentage%'),
            const SizedBox(height: 8),
            Text(
              widget.chartType == 'instrument'
                  ? 'This instrument represents $percentage% of your total trading activity.'
                  : 'This strategy represents $percentage% of your total trades.',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Colors.white.withValues(alpha: 0.7),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }
}

class BarChartPainter extends CustomPainter {
  final Map<String, int> data;
  final double animationValue;
  final int maxValue;
  final String? hoveredBar;
  final String chartType;

  BarChartPainter({
    required this.data,
    required this.animationValue,
    required this.maxValue,
    this.hoveredBar,
    required this.chartType,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (data.isEmpty) return;

    final barWidth = size.width / data.length * 0.7;
    final barSpacing = size.width / data.length * 0.3;
    final chartHeight = size.height - 60; // Leave space for labels

    // Draw grid lines
    _drawGrid(canvas, size, chartHeight);

    // Draw bars
    double x = barSpacing / 2;
    for (final entry in data.entries) {
      final barHeight = (entry.value / maxValue) * chartHeight * animationValue;
      final isHovered = hoveredBar == entry.key;
      
      _drawBar(canvas, x, size.height - 40, barWidth, barHeight, entry.key, isHovered);
      _drawLabel(canvas, x + barWidth / 2, size.height - 30, entry.key);
      
      x += barWidth + barSpacing;
    }

    // Draw Y-axis labels
    _drawYAxisLabels(canvas, size, chartHeight);
  }

  void _drawGrid(Canvas canvas, Size size, double chartHeight) {
    final gridPaint = Paint()
      ..color = Colors.white.withValues(alpha: 0.1)
      ..strokeWidth = 1;

    // Horizontal grid lines
    for (int i = 0; i <= 5; i++) {
      final y = size.height - 40 - (chartHeight / 5 * i);
      canvas.drawLine(
        Offset(0, y),
        Offset(size.width, y),
        gridPaint,
      );
    }
  }

  void _drawBar(Canvas canvas, double x, double baseY, double width, double height,
      String key, bool isHovered) {
    final color = _getColorForItem(key);
    
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    final rect = RRect.fromRectAndRadius(
      Rect.fromLTWH(x, baseY - height, width, height),
      const Radius.circular(4),
    );

    // Draw shadow for hovered bar
    if (isHovered) {
      final shadowPaint = Paint()
        ..color = Colors.black.withValues(alpha: 0.2)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 4);
      
      canvas.drawRRect(
        RRect.fromRectAndRadius(
          Rect.fromLTWH(x + 2, baseY - height + 2, width, height),
          const Radius.circular(4),
        ),
        shadowPaint,
      );
    }

    // Draw main bar
    canvas.drawRRect(rect, paint);

    // Draw border
    final borderPaint = Paint()
      ..color = color.withValues(alpha: 0.8)
      ..style = PaintingStyle.stroke
      ..strokeWidth = isHovered ? 2 : 1;
    
    canvas.drawRRect(rect, borderPaint);

    // Draw value on top of bar
    if (height > 20) {
      final value = data[key] ?? 0;
      _drawValueText(canvas, x + width / 2, baseY - height - 5, '$value');
    }
  }

  void _drawLabel(Canvas canvas, double x, double y, String label) {
    final textPainter = TextPainter(
      text: TextSpan(
        text: label.length > 8 ? '${label.substring(0, 8)}...' : label,
        style: const TextStyle(
          color: Colors.white70,
          fontSize: 11,
        ),
      ),
      textAlign: TextAlign.center,
      textDirection: TextDirection.ltr,
    );
    
    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(x - textPainter.width / 2, y),
    );
  }

  void _drawValueText(Canvas canvas, double x, double y, String value) {
    final textPainter = TextPainter(
      text: TextSpan(
        text: value,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 10,
          fontWeight: FontWeight.w600,
        ),
      ),
      textAlign: TextAlign.center,
      textDirection: TextDirection.ltr,
    );
    
    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(x - textPainter.width / 2, y - textPainter.height),
    );
  }

  void _drawYAxisLabels(Canvas canvas, Size size, double chartHeight) {
    for (int i = 0; i <= 5; i++) {
      final value = (maxValue / 5 * i).round();
      final y = size.height - 40 - (chartHeight / 5 * i);
      
      final textPainter = TextPainter(
        text: TextSpan(
          text: '$value',
          style: const TextStyle(
            color: Colors.white54,
            fontSize: 10,
          ),
        ),
        textAlign: TextAlign.right,
        textDirection: TextDirection.ltr,
      );
      
      textPainter.layout();
      textPainter.paint(
        canvas,
        Offset(-textPainter.width - 8, y - textPainter.height / 2),
      );
    }
  }

  Color _getColorForItem(String item) {
    const colors = [
      Color(0xFF3B82F6), // Blue
      Color(0xFF10B981), // Green
      Color(0xFFF59E0B), // Yellow
      Color(0xFFEF4444), // Red
      Color(0xFF8B5CF6), // Purple
      Color(0xFFF97316), // Orange
      Color(0xFF06B6D4), // Cyan
      Color(0xFFEC4899), // Pink
    ];
    
    final index = item.hashCode.abs() % colors.length;
    return colors[index];
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}