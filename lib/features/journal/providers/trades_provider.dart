// Auto-generated by TradeVerseAI Agent
// Purpose: Trades provider for managing trade data with Riverpod and Supabase

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/trade_model.dart';

// Supabase client provider
final supabaseProvider = Provider<SupabaseClient>((ref) {
  return Supabase.instance.client;
});

// Trades repository provider
final tradesRepositoryProvider = Provider<TradesRepository>((ref) {
  final supabase = ref.watch(supabaseProvider);
  return TradesRepository(supabase);
});

// Main trades provider
final tradesProvider = AsyncNotifierProvider<TradesNotifier, List<Trade>>(() {
  return TradesNotifier();
});

// Individual trade provider
final tradeProvider = Provider.family<AsyncValue<Trade?>, String>((ref, tradeId) {
  final tradesAsync = ref.watch(tradesProvider);
  return tradesAsync.whenData((trades) {
    try {
      return trades.firstWhere((trade) => trade.id == tradeId);
    } catch (e) {
      return null;
    }
  });
});

// Trades notifier class
class TradesNotifier extends AsyncNotifier<List<Trade>> {
  @override
  Future<List<Trade>> build() async {
    final repository = ref.read(tradesRepositoryProvider);
    return await repository.getAllTrades();
  }

  // Add a new trade
  Future<void> addTrade(Trade trade) async {
    final repository = ref.read(tradesRepositoryProvider);
    
    // Optimistic update
    final currentTrades = state.valueOrNull ?? [];
    state = AsyncData([trade, ...currentTrades]);
    
    try {
      await repository.insertTrade(trade);
      // Refresh to get the latest data
      ref.invalidateSelf();
    } catch (e) {
      // Rollback optimistic update
      state = AsyncData(currentTrades);
      rethrow;
    }
  }

  // Update an existing trade
  Future<void> updateTrade(Trade updatedTrade) async {
    final repository = ref.read(tradesRepositoryProvider);
    
    // Optimistic update
    final currentTrades = state.valueOrNull ?? [];
    final updatedTrades = currentTrades.map((trade) {
      return trade.id == updatedTrade.id ? updatedTrade : trade;
    }).toList();
    state = AsyncData(updatedTrades);
    
    try {
      await repository.updateTrade(updatedTrade);
    } catch (e) {
      // Rollback optimistic update
      state = AsyncData(currentTrades);
      rethrow;
    }
  }

  // Delete a trade
  Future<void> deleteTrade(String tradeId) async {
    final repository = ref.read(tradesRepositoryProvider);
    
    // Optimistic update
    final currentTrades = state.valueOrNull ?? [];
    final updatedTrades = currentTrades.where((trade) => trade.id != tradeId).toList();
    state = AsyncData(updatedTrades);
    
    try {
      await repository.deleteTrade(tradeId);
    } catch (e) {
      // Rollback optimistic update
      state = AsyncData(currentTrades);
      rethrow;
    }
  }

  // Close a trade
  Future<void> closeTrade(String tradeId, double exitPrice, {String? notes}) async {
    final currentTrades = state.valueOrNull ?? [];
    
    final tradeIndex = currentTrades.indexWhere((trade) => trade.id == tradeId);
    if (tradeIndex == -1) return;
    
    final trade = currentTrades[tradeIndex];
    final pnl = _calculatePnl(trade, exitPrice);
    
    final closedTrade = trade.copyWith(
      status: TradeStatus.closed,
      exitPrice: exitPrice,
      exitTime: DateTime.now(),
      pnl: pnl,
      notes: notes ?? trade.notes,
      updatedAt: DateTime.now(),
    );
    
    await updateTrade(closedTrade);
  }

  // Helper method to calculate P&L
  double _calculatePnl(Trade trade, double exitPrice) {
    final entryValue = trade.entryPrice * trade.quantity;
    final exitValue = exitPrice * trade.quantity;
    
    if (trade.type == TradeType.buy) {
      return exitValue - entryValue;
    } else {
      return entryValue - exitValue;
    }
  }
}

// Repository class for Supabase operations
class TradesRepository {
  final SupabaseClient _supabase;
  static const String _tableName = 'trades';

  TradesRepository(this._supabase);

  // Get all trades for the current user
  Future<List<Trade>> getAllTrades() async {
    try {
      final response = await _supabase
          .from(_tableName)
          .select()
          .order('entry_time', ascending: false);

      return (response as List)
          .map((json) => Trade.fromJson(json as Map<String, dynamic>))
          .toList();
    } catch (e) {
      // If table doesn't exist or no trades, return mock data for development
      return _getMockTrades();
    }
  }

  // Insert a new trade
  Future<void> insertTrade(Trade trade) async {
    await _supabase.from(_tableName).insert(trade.toJson());
  }

  // Update an existing trade
  Future<void> updateTrade(Trade trade) async {
    await _supabase
        .from(_tableName)
        .update(trade.toJson())
        .eq('id', trade.id);
  }

  // Delete a trade
  Future<void> deleteTrade(String tradeId) async {
    await _supabase
        .from(_tableName)
        .delete()
        .eq('id', tradeId);
  }

  // Get trades by status
  Future<List<Trade>> getTradesByStatus(TradeStatus status) async {
    final response = await _supabase
        .from(_tableName)
        .select()
        .eq('status', status.toString().split('.').last)
        .order('entry_time', ascending: false);

    return (response as List)
        .map((json) => Trade.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  // Get trades by date range
  Future<List<Trade>> getTradesByDateRange(DateTime start, DateTime end) async {
    final response = await _supabase
        .from(_tableName)
        .select()
        .gte('entry_time', start.toIso8601String())
        .lte('entry_time', end.toIso8601String())
        .order('entry_time', ascending: false);

    return (response as List)
        .map((json) => Trade.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  // Mock data for development/demo purposes
  List<Trade> _getMockTrades() {
    final now = DateTime.now();
    return [
      Trade(
        id: '1',
        symbol: 'AAPL',
        type: TradeType.buy,
        status: TradeStatus.closed,
        timeframe: TradeTimeframe.d1,
        entryPrice: 150.00,
        exitPrice: 165.00,
        quantity: 100,
        entryTime: now.subtract(const Duration(days: 5)),
        exitTime: now.subtract(const Duration(days: 2)),
        pnl: 1500.00,
        notes: 'Strong earnings report, broke resistance',
        createdAt: now.subtract(const Duration(days: 5)),
        updatedAt: now.subtract(const Duration(days: 2)),
      ),
      Trade(
        id: '2',
        symbol: 'TSLA',
        type: TradeType.buy,
        status: TradeStatus.open,
        timeframe: TradeTimeframe.h4,
        entryPrice: 800.00,
        quantity: 50,
        entryTime: now.subtract(const Duration(days: 3)),
        pnl: -500.00, // Current unrealized P&L
        stopLoss: 750.00,
        takeProfit: 900.00,
        notes: 'EV sector momentum trade',
        createdAt: now.subtract(const Duration(days: 3)),
        updatedAt: now.subtract(const Duration(days: 3)),
      ),
      Trade(
        id: '3',
        symbol: 'MSFT',
        type: TradeType.buy,
        status: TradeStatus.closed,
        timeframe: TradeTimeframe.d1,
        entryPrice: 300.00,
        exitPrice: 285.00,
        quantity: 75,
        entryTime: now.subtract(const Duration(days: 10)),
        exitTime: now.subtract(const Duration(days: 6)),
        pnl: -1125.00,
        notes: 'Tech selloff, cut losses early',
        createdAt: now.subtract(const Duration(days: 10)),
        updatedAt: now.subtract(const Duration(days: 6)),
      ),
      Trade(
        id: '4',
        symbol: 'GOOGL',
        type: TradeType.buy,
        status: TradeStatus.closed,
        timeframe: TradeTimeframe.d1,
        entryPrice: 2500.00,
        exitPrice: 2680.00,
        quantity: 10,
        entryTime: now.subtract(const Duration(days: 14)),
        exitTime: now.subtract(const Duration(days: 8)),
        pnl: 1800.00,
        notes: 'AI hype driving growth',
        createdAt: now.subtract(const Duration(days: 14)),
        updatedAt: now.subtract(const Duration(days: 8)),
      ),
      Trade(
        id: '5',
        symbol: 'NVDA',
        type: TradeType.buy,
        status: TradeStatus.closed,
        timeframe: TradeTimeframe.h4,
        entryPrice: 400.00,
        exitPrice: 420.00,
        quantity: 25,
        entryTime: now.subtract(const Duration(days: 1)),
        exitTime: now.subtract(const Duration(hours: 4)),
        pnl: 500.00,
        notes: 'Quick scalp on chip rally',
        createdAt: now.subtract(const Duration(days: 1)),
        updatedAt: now.subtract(const Duration(hours: 4)),
      ),
    ];
  }
}