// Auto-generated by TradeVerseAI Agent
// Purpose: Trade model with all necessary fields for journal functionality

import 'package:flutter/foundation.dart';

enum TradeType { buy, sell }
enum TradeStatus { open, closed }
enum TradeTimeframe { m1, m5, m15, h1, h4, d1, w1 }

@immutable
class Trade {
  final String id;
  final String symbol;
  final TradeType type;
  final TradeStatus status;
  final TradeTimeframe timeframe;
  final double entryPrice;
  final double? exitPrice;
  final double quantity;
  final DateTime entryTime;
  final DateTime? exitTime;
  final double pnl;
  final double? stopLoss;
  final double? takeProfit;
  final String notes;
  final List<String> attachedImages;
  final Map<String, dynamic> metadata;
  final String? strategy;
  final double? riskRewardRatio;
  final DateTime createdAt;
  final DateTime updatedAt;

  const Trade({
    required this.id,
    required this.symbol,
    required this.type,
    required this.status,
    required this.timeframe,
    required this.entryPrice,
    this.exitPrice,
    required this.quantity,
    required this.entryTime,
    this.exitTime,
    required this.pnl,
    this.stopLoss,
    this.takeProfit,
    this.notes = '',
    this.attachedImages = const [],
    this.metadata = const {},
    this.strategy,
    this.riskRewardRatio,
    required this.createdAt,
    required this.updatedAt,
  });

  // Computed properties
  bool get isProfitable => pnl > 0;
  bool get isLoss => pnl < 0;
  bool get isBreakeven => pnl == 0;
  bool get isOpen => status == TradeStatus.open;
  bool get isClosed => status == TradeStatus.closed;
  
  double get totalValue => entryPrice * quantity;
  double? get exitValue => exitPrice != null ? exitPrice! * quantity : null;
  
  Duration get holdingPeriod {
    final endTime = exitTime ?? DateTime.now();
    return endTime.difference(entryTime);
  }
  
  String get holdingPeriodString {
    final duration = holdingPeriod;
    if (duration.inDays > 0) {
      return '${duration.inDays}d ${duration.inHours % 24}h';
    } else if (duration.inHours > 0) {
      return '${duration.inHours}h ${duration.inMinutes % 60}m';
    } else {
      return '${duration.inMinutes}m';
    }
  }

  // Copy with method for updates
  Trade copyWith({
    String? id,
    String? symbol,
    TradeType? type,
    TradeStatus? status,
    TradeTimeframe? timeframe,
    double? entryPrice,
    double? exitPrice,
    double? quantity,
    DateTime? entryTime,
    DateTime? exitTime,
    double? pnl,
    double? stopLoss,
    double? takeProfit,
    String? notes,
    List<String>? attachedImages,
    Map<String, dynamic>? metadata,
    String? strategy,
    double? riskRewardRatio,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return Trade(
      id: id ?? this.id,
      symbol: symbol ?? this.symbol,
      type: type ?? this.type,
      status: status ?? this.status,
      timeframe: timeframe ?? this.timeframe,
      entryPrice: entryPrice ?? this.entryPrice,
      exitPrice: exitPrice ?? this.exitPrice,
      quantity: quantity ?? this.quantity,
      entryTime: entryTime ?? this.entryTime,
      exitTime: exitTime ?? this.exitTime,
      pnl: pnl ?? this.pnl,
      stopLoss: stopLoss ?? this.stopLoss,
      takeProfit: takeProfit ?? this.takeProfit,
      notes: notes ?? this.notes,
      attachedImages: attachedImages ?? this.attachedImages,
      metadata: metadata ?? this.metadata,
      strategy: strategy ?? this.strategy,
      riskRewardRatio: riskRewardRatio ?? this.riskRewardRatio,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  // JSON serialization
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'symbol': symbol,
      'type': type.toString().split('.').last,
      'status': status.toString().split('.').last,
      'timeframe': timeframe.toString().split('.').last,
      'entry_price': entryPrice,
      'exit_price': exitPrice,
      'quantity': quantity,
      'entry_time': entryTime.toIso8601String(),
      'exit_time': exitTime?.toIso8601String(),
      'pnl': pnl,
      'stop_loss': stopLoss,
      'take_profit': takeProfit,
      'notes': notes,
      'attached_images': attachedImages,
      'metadata': metadata,
      'strategy': strategy,
      'risk_reward_ratio': riskRewardRatio,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
    };
  }

  // JSON deserialization
  factory Trade.fromJson(Map<String, dynamic> json) {
    return Trade(
      id: json['id'] as String,
      symbol: json['symbol'] as String,
      type: TradeType.values.firstWhere(
        (e) => e.toString().split('.').last == json['type'],
      ),
      status: TradeStatus.values.firstWhere(
        (e) => e.toString().split('.').last == json['status'],
      ),
      timeframe: TradeTimeframe.values.firstWhere(
        (e) => e.toString().split('.').last == json['timeframe'],
      ),
      entryPrice: (json['entry_price'] as num).toDouble(),
      exitPrice: json['exit_price'] != null 
          ? (json['exit_price'] as num).toDouble() 
          : null,
      quantity: (json['quantity'] as num).toDouble(),
      entryTime: DateTime.parse(json['entry_time'] as String),
      exitTime: json['exit_time'] != null 
          ? DateTime.parse(json['exit_time'] as String) 
          : null,
      pnl: (json['pnl'] as num).toDouble(),
      stopLoss: json['stop_loss'] != null 
          ? (json['stop_loss'] as num).toDouble() 
          : null,
      takeProfit: json['take_profit'] != null 
          ? (json['take_profit'] as num).toDouble() 
          : null,
      notes: json['notes'] as String? ?? '',
      attachedImages: (json['attached_images'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList() ?? [],
      metadata: json['metadata'] as Map<String, dynamic>? ?? {},
      strategy: json['strategy'] as String?,
      riskRewardRatio: json['risk_reward_ratio'] != null 
          ? (json['risk_reward_ratio'] as num).toDouble() 
          : null,
      createdAt: DateTime.parse(json['created_at'] as String),
      updatedAt: DateTime.parse(json['updated_at'] as String),
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Trade && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() {
    return 'Trade(id: $id, symbol: $symbol, type: $type, pnl: $pnl)';
  }
}

// Extension methods for easier formatting
extension TradeExtensions on Trade {
  String get formattedPnl {
    final sign = pnl >= 0 ? '+' : '';
    return '$sign\$${pnl.toStringAsFixed(2)}';
  }

  String get formattedEntryPrice {
    return '\$${entryPrice.toStringAsFixed(2)}';
  }

  String get formattedExitPrice {
    return exitPrice != null ? '\$${exitPrice!.toStringAsFixed(2)}' : 'N/A';
  }

  String get typeDisplayName {
    return type == TradeType.buy ? 'BUY' : 'SELL';
  }

  String get statusDisplayName {
    return status == TradeStatus.open ? 'Open' : 'Closed';
  }

  String get timeframeDisplayName {
    switch (timeframe) {
      case TradeTimeframe.m1:
        return '1m';
      case TradeTimeframe.m5:
        return '5m';
      case TradeTimeframe.m15:
        return '15m';
      case TradeTimeframe.h1:
        return '1H';
      case TradeTimeframe.h4:
        return '4H';
      case TradeTimeframe.d1:
        return '1D';
      case TradeTimeframe.w1:
        return '1W';
    }
  }
}